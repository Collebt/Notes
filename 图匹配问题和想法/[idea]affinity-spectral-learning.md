# 构建affinity matrix衡量图的相似度

在图匹配中，使用affinity矩阵的情况很多，但是计算效率比较低，因为矩阵是对称（信息冗余），并且稀疏。

传统方法大多是用求最大特征向量作为最优解，因此想通过迭代出affinity的最大特征向量，然后将数值大的作为匹配点。



## 实验的问题

目前写完代码后，效果不好，主要原因是迭代会造成特征的平滑，而且每一次的迭代出来的数值只有最可能匹配的节点，无法同时解决大规模的图问题。在匹配效率上就很低。











## 可视化部分



![image-20211112171252134](image-20211112171252134.png)











use the M of affinity matrix:

![image-20211112184036129](image-20211112184036129.png)



after 1 epoch:

![image-20211112193857668](image-20211112193857668.png)



lucky case:

![image-20211112204822065](image-20211112204822065.png)



![image-20211112204854349](image-20211112204854349.png)

![image-20211112204916288](image-20211112204916288.png)



only use F.normlize(vec_S):

![image-20211112205436251](image-20211112205436251.png)





![image-20211112210848999](image-20211112210848999.png)







![image-20211112211253798](image-20211112211253798.png)

![image-20211112231022133](image-20211112231022133.png)





![image-20211112231139921](image-20211112231139921.png)

![image-20211112231222698](image-20211112231222698.png)

![image-20211116110057039](image-20211116110057039.png)





![image-20211116110128366](image-20211116110128366.png)

![image-20211116122431398](image-20211116122431398.png)

![image-20211116135043531](image-20211116135043531.png)



- use softmax for everynode



- repaire the affinity

![image-20211119105513400](image-20211119105513400.png)



- ```
  S_output[:ns, :nt] = (1 - lam) * S_x + lam * S_select
  ```

  

![image-20211119171302299](image-20211119171302299.png)

